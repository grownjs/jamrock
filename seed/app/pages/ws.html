<script context="module">
  let t = 420;
  let j = 0;

  function* sendMessage({ message, interval }) {
    yield { v: +message, i: j++, o: '!!!' };
    t = interval;
  }
</script>

<script>
  import { reply } from 'jamrock/conn';

  // FIXME: streams should be auto-prefixed with the component's key,
  // so we can have several streams with the same source... PRETTY SIMILAR AS BINDINGS!!
  async function* aGenerator() {
    let i = 0;
    while (true) {
      if (i > 2500) break;
      yield { v: Math.random() * 100 + j | 0, i: j++, o: '' };
      if (i++ > 50 && t) await new Promise(ok => setTimeout(ok, Math.random() * t + 1));
    }
  }

  let result;
  export default {
    doSomething(payload) {
      // reply({
      //   aGenerator: { v: 420, i: j++, o: '???' },
      //   // FIXME: below is not working...
      //   // target: { result: payload.sample },
      // });
      reply('target', { result: payload.sample });
      reply('aGenerator', {
        aGenerator: { v: 420, i: j++, o: '???' },
        // FIXME: below is not working...
        // target: { result: payload.sample },
      });
    },
  };
</script>

<style scoped>
  ol {
    overflow: auto;
    height: 30em;
    line-height: 1;
  }
  div {
    display: flex;
  }
  .match {
    background-color: rgba(0, 255, 0, .5);
  }
</style>

<div>
  <form @async="clear message" @trigger="{sendMessage >> aGenerator}" style="width:50%">
    <p>Type a number below, as it matches the current offset you'll notice:</p>
    Interval: <input type="number" name="interval" value={t} /><br />
    Your guess: <input type="text" name="message" />
    <button :disabled>Send</button>
  </form>
  <form @trigger="doSomething">
    <input type="text" name="sample" />
    <button :disabled>OK</button>
    <fragment id="target">
      {#if result}
        <p>Got: {result}</p>
      {/if}
    </fragment>
  </form>
</div>
<p>Items:</p>
<ol>
  <li>BEFORE (make a game of this... right?)</li>
  <li>MATH: each match scores, less distance between hits scores higher! they can be letters, numbers, emojis, etc.</li>
  <fragment id="aGenerator" interval="150" mode="prepend">
    {#each aGenerator as x}
      <li class="{x.v === x.i ? 'match' : null}">
        {x.v === x.i ? 'YES' : 'NO'}: {x.v} ({x.i}{x.o})
      </li>
    {/each}
  </fragment>
  <li>AFTER!!</li>
</ol>
